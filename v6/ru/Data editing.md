---
title: Редактирование данных
layout: default
---
# Редактирование данных #

Под редактированием данных подразумеваются такие действия как создание заказов, манипуляция с их составом, резервирование столов, регистрация гостей и т. п. Каждое отдельно взятое действие вносит небольшое точечное изменение — например, `AddOrderItemProduct` добавляет в заказ блюдо, а `AddOrderItemModifier` добавляет к блюду модификатор. Многие действия сами по себе могут приводить данные к несогласованному состоянию — к примеру, если блюдо имеет обязательные модификаторы, то добавление блюда без модификаторов нарушило бы соответствующее правило предметной области. Комбинируя эти действия, можно добавить в заказ блюдо с модификаторами. При этом важно, чтобы набор действий выполнялся с соблюдением принципа «всё или ничего» и переводил данные из одного согласованного состояния в другое согласованное состояние. Для обеспечения транзакционности при изменении данных вводится понятие *сессии редактирования*. 

## Сессии редактирования ##
Сессия редактирования — это некое подобие транзакций в базах данных. Все действия, даже одиночные, выполняются в рамках сессий следующим образом:

1. Создаётся сессия `IEditSession` с помощью вызова `PluginContext.Operations.CreateEditSession`.
2. В рамках сессии выполняется одно или несколько действий.
3. Сделанные изменения сохраняются методом `PluginContext.Operations.SubmitChanges`.

Сделанные на втором шаге изменения не видны до их успешного сохранения. На третьем шаге либо все изменения успешно записываются, либо все откатываются и генерируется исключение. 

## Синхронизация ##
Доступ к данным синхронизирован с помощью блокировок и ревизий. На время редактирования объекты блокируются, но через Api напрямую управлять блокировками невозможно — объекты блокируются автоматически при сохранении изменений (`SubmitChanges`). Это соответствует концепции *оптимистических блокировок*: на этапах создания сессии редактирования и выполнения действий объекты не блокируются, а при сохранении сделанных изменений происходит проверка, не изменились ли они в это же время кем-то другим. При каждом изменении объектам назначается новая ревизия, что позволяет различать разные версии одного и того же объекта. С учётом низкой конкуренции за параллельное редактирование одних и тех же объектов такой подход позволяет упростить программный интерфейс (нет методов управления блокировками, не надо заботиться об их корректном освобождении) и обеспечить доступность данных (невозможно надолго заблокировать объект, невозможно «забыть» отпустить блокировку, в случае аварийного завершения работы плагина объект не зависнет в заблокированном состоянии).

Следует учитывать некоторые особенности реализации:

- Само приложение iikoFront может блокировать объекты на длительное время (*пессимистические блокировки*). Например, при переходе на экран редактирования заказа соответствующий заказ будет заблокирован как минимум на всё время нахождения на этом экране (дальше зависит от того, на какой экран перейдёт пользователь). В это время редактировать заблокированный заказ через Api невозможно. Имеет смысл предупредить официантов, чтобы они, отходя от стационарного терминала, блокировали экран, либо указать небольшой интервал времени для автоблокировки (по умолчанию 10 минут). Кроме того, объекты могут быть заблокированы ненадолго без участия пользователя (например, при внесении изменений по таймеру).
- При блокировании какого-либо объекта вместе с ним автоматически блокируются и связанные объекты. Так, например, при блокировании банкетного заказа также будет заблокирован соответствующий резерв, а вместе с ним и клиент. Если хоть один из объектов не удалось заблокировать, операция завершается неуспешно. Соответственно, когда на стационарном терминале редактируется банкетный заказ, зарегистрированный на определённого клиента, не удастся внести изменения в доставку, заказанную тем же клиентом.
- Для корректной работы синхронизации доступа к данным необходимо с помощью iikoOffice в настройках группы назначить главную кассу. Плагин, использующий функции редактирования данных, предпочтительно устанавливать на главную кассу. Установка на другие терминалы допускается, но в некоторых сценариях возможны разовые отказы в применении изменений, вызванные деталями реализации. Возможно, в одной из следующих версий эти ограничения будут сняты.

## Заглушки ##
Так как результаты действий невозможно получить до сохранения всей сессии, при выполнении последовательности действий в рамках одной сессии бывает необходимо сослаться на создаваемый, но ещё не существующий объект. Например, вслед за созданием заказа нужна возможность добавить в него гостя, этому гостю — блюдо, а блюду — модификатор, хотя при этом ещё нет ни заказа, ни гостя, ни блюда. Для этой цели вводится понятие заглушек объектов — неких фиктивных, однако, однозначных указателей на объекты. Действия создания объектов, такие как `CreateOrder` или `AddOrderGuest`, возвращают заглушки вида `INew...Stub`, которые в рамках той же сессии можно использовать вместо будущих объектов.

Большинство методов редактирования принимают в качестве аргументов подобные заглушки, что позволяет передавать в них как существующие, так и новые объекты. Например, метод `SetOrderType` принимает `IOrderStub`, поэтому можно задать тип и уже существующему заказу (`IOrder : IOrderStub`), и только создаваемому (`INewOrderStub : IOrderStub`). 

Впрочем, некоторые действия могут требовать строго одного из двух — нового или существующего объекта, в таком случае в сигнатуре метода будет использован не базовый тип, а один из наследников.

## Ожидаемые исключения ##
При попытке сохранить изменения могут возникать различные исключения. Некоторые из них могут свидетельствовать об ошибке в коде плагина (например, `ArgumentNullException` или `ArgumentOutOfRangeException`), подавлять такие исключения не рекомендуется (лучше исправить ошибку в коде). Однако, некоторые исключения предугадать или предотвратить невозможно, их следует перехватывать и корректно обрабатывать: 

- `EntityAlreadyInUseException` — попытка применить изменения к объекту, который в этот момент заблокирован. Можно повторить попытку позднее.
- `EntityModifiedException` — попытка применить изменения к старой версии объекта. Это означает, что после того, как плагин прочитал объект, этот объект был кем-то изменён. Необходимо повторно прочитать объект и, если запланированные изменения всё ещё актуальны, повторно применить их.
- `PermissionDeniedException` — попытка выполнить действия, не имея достаточных прав. Если пользователь хочет, чтобы плагин мог выполнять эти действия, ему следует выдать соответствующие права с помощью iikoOffice.
- ...
 
## Синтаксический сахар ##
Иногда требуется выполнить всего одно действие, при этом явное создание сессии редактирование выглядит громоздким. Для таких случаев к `IOperationService` реализованы вспомогательные extension-методы, которые создают сессию редактирования, выполняют единственное действие, сохраняют изменения и возвращают результат действия. В принципе всё то же самое можно было написать вручную. Не рекомендуется использовать эти обёртки, если предполагается одновременное выполнение нескольких действий.
